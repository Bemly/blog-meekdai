<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>蓝莓小果冻的博客</title><link>https://Bemly.github.io/blog-meekdai</link><description>一个喜欢尝鲜却苦于没有技术的小透明&lt;br /&gt;此乃镜像博客，由「Gmeek框架 + Py.jinja2解释器 + utteranc 评论系统」驱动</description><copyright>蓝莓小果冻的博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/48025099?v=4&amp;size=64</url><title>avatar</title><link>https://Bemly.github.io/blog-meekdai</link></image><lastBuildDate>Fri, 23 Aug 2024 21:05:39 +0000</lastBuildDate><managingEditor>蓝莓小果冻的博客</managingEditor><ttl>60</ttl><webMaster>蓝莓小果冻的博客</webMaster><item><title>评论系统 测试区捏，欢迎鞭打</title><link>https://Bemly.github.io/blog-meekdai/post/ping-lun-xi-tong-%20-ce-shi-qu-nie-%EF%BC%8C-huan-ying-bian-da.html</link><description>&#13;
#5 &#13;
&#13;
#4 &#13;
&#13;
#3 &#13;
&#13;
#2 &#13;
&#13;
#1 &#13;
&#13;
# 随便ky昂 嘿嘿&#13;
&#13;
评论系统使用的是 开源的 [utteranc.es](https://utteranc.es/) 白嫖系统，&#13;
&#13;
主打的就是利用 github issue 自托管来实现评论效果，&#13;
&#13;
2017 年的大众工具，如今快沦落到无人知晓的地步了（悲。</description><guid isPermaLink="true">https://Bemly.github.io/blog-meekdai/post/ping-lun-xi-tong-%20-ce-shi-qu-nie-%EF%BC%8C-huan-ying-bian-da.html</guid><pubDate>Fri, 23 Aug 2024 21:05:02 +0000</pubDate></item><item><title>ANSI 转义标识符 的 用法</title><link>https://Bemly.github.io/blog-meekdai/post/ANSI%20-zhuan-yi-biao-shi-fu-%20-de-%20-yong-fa.html</link><description>最近在写 TUI terminal UI界面，需要用到&#13;
&#13;
鼠标来控制坐标，索性了解来一下 ANSI 的用法&#13;
&#13;
下面是原作者写的 Gist，个人觉得已经非常详细了，遂即把这个翻译出来给大家分享分享：&#13;
&#13;
{% gist 458719343aabd01cfb17a3a4f7296797 %}&#13;
&#13;
&lt;script src='https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797.js'&gt;&lt;/script&gt;&#13;
&#13;
翻译稿：&#13;
&#13;
{% gist 25b4391d1c34c5e3d1fbb238634570b2 %}&#13;
&#13;
&lt;script src='https://gist.github.com/Bemly/25b4391d1c34c5e3d1fbb238634570b2.js'&gt;&lt;/script&gt;&#13;
&#13;
# ANSI 转义标识符&#13;
&#13;
标准转义码的前缀是 `Escape` 脱离键，常用名`ESC键`:&#13;
&#13;
- Ctrl 键: `^[`&#13;
- 八进制: `\033`&#13;
- Unicode编码: `\u001b`&#13;
- 16进制: `\x1B`&#13;
- 十进制: `27`&#13;
&#13;
ESC 后面跟命令，用左方括号（`[`）分隔，一同称为控制标识符导入器（CSI），\&#13;
CSI 后面还可以跟参数和命令本身。</description><guid isPermaLink="true">https://Bemly.github.io/blog-meekdai/post/ANSI%20-zhuan-yi-biao-shi-fu-%20-de-%20-yong-fa.html</guid><pubDate>Fri, 23 Aug 2024 20:57:11 +0000</pubDate></item><item><title>记录一下安装达芬奇剪辑软件的离谱经历（涉及pkexec fakeroot appimage run lib64）</title><link>https://Bemly.github.io/blog-meekdai/post/ji-lu-yi-xia-an-zhuang-da-fen-qi-jian-ji-ruan-jian-de-li-pu-jing-li-%EF%BC%88-she-ji-pkexec%20fakeroot%20appimage%20run%20lib64%EF%BC%89.html</link><description>包上报错查找的安装时长：2个小时（服了） 写文章：半个小时&#13;
&#13;
官网拔下来压缩包然后unzip&#13;
&#13;
开始非常顺利昂 后面不讲武德昂 &#13;
```&#13;
sudo chmod +x ./DaVinci_Resolve_19.0b6_Linux.run&#13;
./DaVinci_Resolve_19.0b6_Linux.run&#13;
```&#13;
草 然后就悲剧了（原因就是pkexec这个superuser-agent大神)&#13;
&#13;
```&#13;
==== AUTHENTICATING FOR org.freedesktop.policykit.exec ====&#13;
Authentication is needed to run `/usr/bin/env PATH=/home/bemly/.cargo/b ... mp/.mount_DaVincYTYBgI /tmp/pDCdqp.sh' as the super user&#13;
Authenticating as: bemly&#13;
Password: &#13;
==== AUTHENTICATION FAILED ====&#13;
Error: Installer failed&#13;
 polkit-agent-helper-1: error response to PolicyKit daemon: GDBus.Error:org.freedesktop.PolicyKit1.Error.Failed: No session for cookie&#13;
Error executing command as another user: Not authorized&#13;
```&#13;
我明明密码都输入对了的 可恶&#13;
&#13;
看上去是pkexec的daemon守护进程有点问题昂 按照惯例我就去重启这个服务&#13;
&#13;
```&#13;
systemctl restart polkit.service&#13;
==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ====&#13;
重新启动“polkit.service”需要认证。</description><guid isPermaLink="true">https://Bemly.github.io/blog-meekdai/post/ji-lu-yi-xia-an-zhuang-da-fen-qi-jian-ji-ruan-jian-de-li-pu-jing-li-%EF%BC%88-she-ji-pkexec%20fakeroot%20appimage%20run%20lib64%EF%BC%89.html</guid><pubDate>Fri, 23 Aug 2024 19:05:32 +0000</pubDate></item><item><title>关于 coffeescript 的 ESM 疑问 （已解决）</title><link>https://Bemly.github.io/blog-meekdai/post/guan-yu-%20coffeescript%20-de-%20ESM%20-yi-wen-%20%EF%BC%88-yi-jie-jue-%EF%BC%89.html</link><description>```&#13;
#!/usr/bin/env coffee&#13;
import * as cfs from 'coffeescript'&#13;
```&#13;
&#13;
```&#13;
 coffee index&#13;
(node:44936) Warning: To load an ES module, set 'type': 'module' in the package.json or use the .mjs extension.&#13;
(Use `node --trace-warnings ...` to show where the warning was created)&#13;
/home/bemly/www/luoli-parse-toolchain/src/index:4&#13;
import * as cfs from 'coffeescript';&#13;
^^^^^^&#13;
&#13;
SyntaxError: Cannot use import statement outside a module&#13;
    at wrapSafe (node:internal/modules/cjs/loader:1469:18)&#13;
    at Module._compile (node:internal/modules/cjs/loader:1491:20)&#13;
    at CoffeeScript.run (/usr/lib/node_modules/coffeescript/lib/coffeescript/index.js:67:23)&#13;
    at compileScript (/usr/lib/node_modules/coffeescript/lib/coffeescript/command.js:285:29)&#13;
    at compilePath (/usr/lib/node_modules/coffeescript/lib/coffeescript/command.js:237:14)&#13;
    at exports.run (/usr/lib/node_modules/coffeescript/lib/coffeescript/command.js:158:20)&#13;
    at Object.&lt;anonymous&gt; (/usr/lib/node_modules/coffeescript/bin/coffee:22:45)&#13;
    at Module._compile (node:internal/modules/cjs/loader:1546:14)&#13;
    at Module._extensions..js (node:internal/modules/cjs/loader:1691:10)&#13;
    at Module.load (node:internal/modules/cjs/loader:1317:32)&#13;
    at Module._load (node:internal/modules/cjs/loader:1127:12)&#13;
    at TracingChannel.traceSync (node:diagnostics_channel:315:14)&#13;
    at wrapModuleLoad (node:internal/modules/cjs/loader:217:24)&#13;
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:166:5)&#13;
    at node:internal/main/run_main_module:30:49&#13;
```&#13;
&#13;
```&#13;
#!/usr/bin/env node&#13;
import * as cfs from 'coffeescript'&#13;
```&#13;
it WORK!!!&#13;
&#13;
而现在的node已经可以正常的识别ESM模式的js了，coffee不知道为什么还没有支持，为什么转义可以识别&#13;
&#13;
source: https://coffeescript.org/#modules&#13;
&#13;
官方的解释：&#13;
&#13;
Note that the CoffeeScript compiler does not resolve modules; writing an import or export statement in CoffeeScript will produce an import or export statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via &lt;script type='module'&gt;) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output .js files are in a folder where the nearest parent package.json file contains 'type': 'module'. Because the runtime is evaluating the generated output, the import statements must reference the output files; so if file.coffee is output as file.js, it needs to be referenced as file.js in the import statement, with the .js extension included.&#13;
&#13;
注意，CoffeeScript编译器不会解析模块;在CoffeeScript中编写import或export语句将在结果输出中生成import或export语句。</description><guid isPermaLink="true">https://Bemly.github.io/blog-meekdai/post/guan-yu-%20coffeescript%20-de-%20ESM%20-yi-wen-%20%EF%BC%88-yi-jie-jue-%EF%BC%89.html</guid><pubDate>Fri, 23 Aug 2024 18:32:55 +0000</pubDate></item><item><title>为什么应该用pnpm作为nodejs的包管理工具</title><link>https://Bemly.github.io/blog-meekdai/post/wei-shen-me-ying-gai-yong-pnpm-zuo-wei-nodejs-de-bao-guan-li-gong-ju.html</link><description>1. 能够识别$XDG_CONFIG_HOME变量，X11 赢！&#13;
2. 可以使用.json5和.yaml来写packages这个遗臭万年的配置文件注释系统 赢！！！&#13;
3. 使用符号链接来管理文件，采用类似Git的文件策略方法管理模块 赢！&#13;
4. 默认的npx，是用的#!/bin/sh来封装的，而不是#!/usr/bin/env node 赢！&#13;
5. 可以用pnpm env来管理nodejs版本 赢！。</description><guid isPermaLink="true">https://Bemly.github.io/blog-meekdai/post/wei-shen-me-ying-gai-yong-pnpm-zuo-wei-nodejs-de-bao-guan-li-gong-ju.html</guid><pubDate>Fri, 23 Aug 2024 18:21:34 +0000</pubDate></item><item><title>js模块化建设历史：AMD、CJS、UMD、ESM</title><link>https://Bemly.github.io/blog-meekdai/post/js-mo-kuai-hua-jian-she-li-shi-%EF%BC%9AAMD%E3%80%81CJS%E3%80%81UMD%E3%80%81ESM.html</link><description>## 起初&#13;
&#13;
最开始的js是用于浏览器的快速脚本语言&#13;
&#13;
动态、宽松语法让许多代码得于以BUG的方式运行起来（（（&#13;
&#13;
但是最开始作为一个脚本语言，并没有考虑到js发展规模之快，以至于ES标准起初没有模块化的要求&#13;
&#13;
随着外部js引入的逐渐增多，各类js的变量出现了冲突&#13;
&#13;
为了解决这个办法，一部分是通过闭包，将自己的变量封装在一个大家基本不会使用的变量名上&#13;
&#13;
比如 jQuery 这名老将，就以自己独特的占有率占用了$这个大变量&#13;
&#13;
模块一多就不太好管理了，譬如现在的Node.js的npm一拉取webpack差不多就有150多个包&#13;
&#13;
这么多模块的变量冲突在处理依赖的时间恐怕要比实际引入开发多得多&#13;
&#13;
此时除了手动闭包冒出变量之外有了新的选择：那就是采用AMD加载器&#13;
&#13;
例如像使用 RequireJS 这种 AMD 加载器，利用define()语法来&#13;
&#13;
自动化帮我们闭包封装各自所需要的模块。</description><guid isPermaLink="true">https://Bemly.github.io/blog-meekdai/post/js-mo-kuai-hua-jian-she-li-shi-%EF%BC%9AAMD%E3%80%81CJS%E3%80%81UMD%E3%80%81ESM.html</guid><pubDate>Fri, 23 Aug 2024 18:09:47 +0000</pubDate></item></channel></rss>