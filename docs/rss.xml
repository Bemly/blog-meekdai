<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>蓝莓小果冻的博客</title><link>https://Bemly.github.io/blog-meekdai</link><description>一个喜欢尝鲜却苦于没有技术的小透明&lt;br /&gt;此乃镜像博客，由「Gmeek框架 + Py.jinja2解释器 + utteranc 评论系统」驱动</description><copyright>蓝莓小果冻的博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/48025099?v=4&amp;size=64</url><title>avatar</title><link>https://Bemly.github.io/blog-meekdai</link></image><lastBuildDate>Fri, 23 Aug 2024 18:33:19 +0000</lastBuildDate><managingEditor>蓝莓小果冻的博客</managingEditor><ttl>60</ttl><webMaster>蓝莓小果冻的博客</webMaster><item><title>关于 coffeescript 的 ESM 疑问 （已解决）</title><link>https://Bemly.github.io/blog-meekdai/post/guan-yu-%20coffeescript%20-de-%20ESM%20-yi-wen-%20%EF%BC%88-yi-jie-jue-%EF%BC%89.html</link><description>```&#13;
#!/usr/bin/env coffee&#13;
import * as cfs from 'coffeescript'&#13;
```&#13;
&#13;
```&#13;
 coffee index&#13;
(node:44936) Warning: To load an ES module, set 'type': 'module' in the package.json or use the .mjs extension.&#13;
(Use `node --trace-warnings ...` to show where the warning was created)&#13;
/home/bemly/www/luoli-parse-toolchain/src/index:4&#13;
import * as cfs from 'coffeescript';&#13;
^^^^^^&#13;
&#13;
SyntaxError: Cannot use import statement outside a module&#13;
    at wrapSafe (node:internal/modules/cjs/loader:1469:18)&#13;
    at Module._compile (node:internal/modules/cjs/loader:1491:20)&#13;
    at CoffeeScript.run (/usr/lib/node_modules/coffeescript/lib/coffeescript/index.js:67:23)&#13;
    at compileScript (/usr/lib/node_modules/coffeescript/lib/coffeescript/command.js:285:29)&#13;
    at compilePath (/usr/lib/node_modules/coffeescript/lib/coffeescript/command.js:237:14)&#13;
    at exports.run (/usr/lib/node_modules/coffeescript/lib/coffeescript/command.js:158:20)&#13;
    at Object.&lt;anonymous&gt; (/usr/lib/node_modules/coffeescript/bin/coffee:22:45)&#13;
    at Module._compile (node:internal/modules/cjs/loader:1546:14)&#13;
    at Module._extensions..js (node:internal/modules/cjs/loader:1691:10)&#13;
    at Module.load (node:internal/modules/cjs/loader:1317:32)&#13;
    at Module._load (node:internal/modules/cjs/loader:1127:12)&#13;
    at TracingChannel.traceSync (node:diagnostics_channel:315:14)&#13;
    at wrapModuleLoad (node:internal/modules/cjs/loader:217:24)&#13;
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:166:5)&#13;
    at node:internal/main/run_main_module:30:49&#13;
```&#13;
&#13;
```&#13;
#!/usr/bin/env node&#13;
import * as cfs from 'coffeescript'&#13;
```&#13;
it WORK!!!&#13;
&#13;
而现在的node已经可以正常的识别ESM模式的js了，coffee不知道为什么还没有支持，为什么转义可以识别&#13;
&#13;
source: https://coffeescript.org/#modules&#13;
&#13;
官方的解释：&#13;
&#13;
Note that the CoffeeScript compiler does not resolve modules; writing an import or export statement in CoffeeScript will produce an import or export statement in the resulting output. Such statements can be run by all modern browsers (when the script is referenced via &lt;script type='module'&gt;) and [by Node.js](https://nodejs.org/api/esm.html#esm_enabling) when the output .js files are in a folder where the nearest parent package.json file contains 'type': 'module'. Because the runtime is evaluating the generated output, the import statements must reference the output files; so if file.coffee is output as file.js, it needs to be referenced as file.js in the import statement, with the .js extension included.&#13;
&#13;
注意，CoffeeScript编译器不会解析模块;在CoffeeScript中编写import或export语句将在结果输出中生成import或export语句。</description><guid isPermaLink="true">https://Bemly.github.io/blog-meekdai/post/guan-yu-%20coffeescript%20-de-%20ESM%20-yi-wen-%20%EF%BC%88-yi-jie-jue-%EF%BC%89.html</guid><pubDate>Fri, 23 Aug 2024 18:32:55 +0000</pubDate></item><item><title>为什么应该用pnpm作为nodejs的包管理工具</title><link>https://Bemly.github.io/blog-meekdai/post/wei-shen-me-ying-gai-yong-pnpm-zuo-wei-nodejs-de-bao-guan-li-gong-ju.html</link><description>1. 能够识别$XDG_CONFIG_HOME变量，X11 赢！&#13;
2. 可以使用.json5和.yaml来写packages这个遗臭万年的配置文件注释系统 赢！！！&#13;
3. 使用符号链接来管理文件，采用类似Git的文件策略方法管理模块 赢！&#13;
4. 默认的npx，是用的#!/bin/sh来封装的，而不是#!/usr/bin/env node 赢！&#13;
5. 可以用pnpm env来管理nodejs版本 赢！。</description><guid isPermaLink="true">https://Bemly.github.io/blog-meekdai/post/wei-shen-me-ying-gai-yong-pnpm-zuo-wei-nodejs-de-bao-guan-li-gong-ju.html</guid><pubDate>Fri, 23 Aug 2024 18:21:34 +0000</pubDate></item><item><title>js模块化建设历史：AMD、CJS、UMD、ESM</title><link>https://Bemly.github.io/blog-meekdai/post/js-mo-kuai-hua-jian-she-li-shi-%EF%BC%9AAMD%E3%80%81CJS%E3%80%81UMD%E3%80%81ESM.html</link><description>## 起初&#13;
&#13;
最开始的js是用于浏览器的快速脚本语言&#13;
&#13;
动态、宽松语法让许多代码得于以BUG的方式运行起来（（（&#13;
&#13;
但是最开始作为一个脚本语言，并没有考虑到js发展规模之快，以至于ES标准起初没有模块化的要求&#13;
&#13;
随着外部js引入的逐渐增多，各类js的变量出现了冲突&#13;
&#13;
为了解决这个办法，一部分是通过闭包，将自己的变量封装在一个大家基本不会使用的变量名上&#13;
&#13;
比如 jQuery 这名老将，就以自己独特的占有率占用了$这个大变量&#13;
&#13;
模块一多就不太好管理了，譬如现在的Node.js的npm一拉取webpack差不多就有150多个包&#13;
&#13;
这么多模块的变量冲突在处理依赖的时间恐怕要比实际引入开发多得多&#13;
&#13;
此时除了手动闭包冒出变量之外有了新的选择：那就是采用AMD加载器&#13;
&#13;
例如像使用 RequireJS 这种 AMD 加载器，利用define()语法来&#13;
&#13;
自动化帮我们闭包封装各自所需要的模块。</description><guid isPermaLink="true">https://Bemly.github.io/blog-meekdai/post/js-mo-kuai-hua-jian-she-li-shi-%EF%BC%9AAMD%E3%80%81CJS%E3%80%81UMD%E3%80%81ESM.html</guid><pubDate>Fri, 23 Aug 2024 18:09:47 +0000</pubDate></item></channel></rss>